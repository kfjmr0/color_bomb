<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>COLOR BOMB!</title>
        
        <!-- style -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
        <audio id="setBombSound" src="http://maoudamashii.jokersounds.com/music/se/mp3/se_maoudamashii_battle07.mp3" preload="auto"></audio>
        <audio id="explodeSound" src="http://maoudamashii.jokersounds.com/music/se/mp3/se_maoudamashii_battle18.mp3" preload="auto"></audio>
        <audio id="pointSound" src="http://maoudamashii.jokersounds.com/music/se/mp3/se_maoudamashii_system49.mp3" preload="auto"></audio>
        <audio id="winSound" src="http://maoudamashii.jokersounds.com/music/se/mp3/se_maoudamashii_instruments_drum1_cymbal.mp3" preload="auto"></audio>
        <audio id="loseSound" src="http://maoudamashii.jokersounds.com/music/se/mp3/se_maoudamashii_onepoint29.mp3" preload="auto"></audio>
        
        <!-- javascript-->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
        <!--
        <script src="js/jquery.event.ue.js"></script>
        -->
        <script src="/socket.io/socket.io.js"></script>
        
        <style type="text/css">
            body {
              font-family: 'sans-serif';
            }
            #header {
              font-size : 24px;
              font-weight : bold;
              font-family : 'Century Gothic';
              background-color : black;
              padding-left : 20px;
              margin-bottom : 20px;
            }
              #header a {
                color : white;
                text-decoration : none;
              }
            .glyphicon-refresh-animate {
                -animation: spin .7s infinite linear;
                -webkit-animation: spin2 .7s infinite linear;
            }
            
            @-webkit-keyframes spin2 {
                from { -webkit-transform: rotate(0deg);}
                to { -webkit-transform: rotate(360deg);}
            }
            
            @keyframes spin {
                from { transform: scale(1) rotate(0deg);}
                to { transform: scale(1) rotate(360deg);}
            }
            #match-offerMatch {
              margin-left: 20px;
            }
            #match-box {
              margin-top: 30px;
              margin-left : 20px;
              width : 400px;
            }
            #canvas {
              border: solid;
              display: block;
            }
            #battle-info {
              font-size : 20px;
              text-align: center;
              height : 50px;
              width: 100%;
            }
            #info-left {
              float : left;
              width : 40%;
              height: 100%;
            }
              #player-name {
                height: 50%;
              }
              #player-score {
                font-size : 15px;
                height: 50%;
              }
            #info-middle {
              font-weight : bold;
              float : left;
              width : 20%;
              height: 100%;
            }
              #opponent-name {
                height: 50%;
              }
              #opponent-score {
                font-size : 15px;
                height: 50%;
              }
            #info-right {
              float : left;
              width : 40%;
              height: 100%;
            }
            #footer {
              padding-left : 20px;
              border-top : solid 1px gray;
              width: 100%;
              position: fixed;
              bottom : 0;
            }
        </style>
    </head>
    
    <body>
        <div id="header"><a href="">COLOR BOMB !</a></div>
        <form id="match-offerMatch" class="form-inline">
            <div class="form-group">
                <label class="sr-only" for="match-offerMatch-name">名前：</label>
                <input class="form-control" type="text" id="match-offerMatch-name" placeholder="名前を入力して下さい"/>
            </div>
            <button id="match-offerMatch-submit" type="submit" class="btn btn-default">対戦相手を探す</button>
        </form>
        
        <div id="match-box">
          <p>～遊び方～</p>
          <p>・ボムを置きたいところをクリックしてボムを置きます。ボムは同時に3つまで置くことができます。ボムが爆発すると四方2マスずつが自分の色で塗られます。また爆発の範囲に別のボムがあれば誘爆します。</p>
          <p>・自分の色である領域の四方を囲むと、その領域も自分の色で塗られ得点が加算されます。囲んだ領域が大きく、同時に複数の領域を囲むほど得点は高くなります。</p>
          <p>・ゲーム終了時に対戦相手より多くのマスを塗っているプレイヤーにはボーナスポイントが加算されます。ボーナスポイントが加算された後、より多くの得点を持っているプレーヤーの勝ちとなります。</p>
        </div>
        
        <div id="footer">効果音：魔王魂</div>
        
        <script>
          /* global $, io, battle, returnFromBattle */
          $(function() {
            var
              socket = io.connect(),
              room, player_id,
              player0_color, player1_color,
              isFakeMatch = false,
              // ----- variables common in server and client/start -----
              CELL_NUM,
              BOMB_NUM,
              TIME_TO_EXPLOSION,
              GAME_DURATIONsec,
              // ----- variables common in server and client/end -----
              configMap = {
                wating_html : String()
                  + '<div class="alert alert-info"><span class="glyphicon glyphicon-refresh glyphicon-refresh-animate"></span>対戦相手を探しています...</div>'
                  + '<button id="match-box-cancel" class="btn btn-danger">キャンセル</button>',
                timeout_html : String()
                  + '<div class="alert alert-danger">対戦相手が見つかりませんでした</div>',
                battle_html : String()
                  + '<div>battle</div>'
                  + '<canvas id="canvas" width="400px" height="400px"></canvas>'
              },
              
              jqueryMap = {
                $offerMatch : $('#match-offerMatch'),
                $name : $('#match-offerMatch-name'),
                $submit : $("#match-offerMatch-submit"),
                $box : $('#match-box'),
              },
              // sounds
              setBombSound = document.getElementById('setBombSound'),
              explodeSound = document.getElementById('explodeSound'),
              pointSound = document.getElementById('pointSound'),
              winSound = document.getElementById('winSound'),
              loseSound = document.getElementById('loseSound')
            ;
              
            // for test match start ------------------------------
            if ( isFakeMatch ) {
              socket.emit('offerMatch', {
                name : 'test_player',
              });
            }
            // for test match end --------------------------------
            
            //
            jqueryMap.$offerMatch.submit( function( e ) {
              var name = jqueryMap.$name.val();
              e.preventDefault();
              if ( ! name ) { return false; }
              jqueryMap.$box.empty();
              
              socket.emit('offerMatch', {
                name : name,
              });
              jqueryMap.$box.append( configMap.wating_html );
              jqueryMap.$submit.prop("disabled", true);
              
              // setting cancel button
              $("#match-box-cancel").click( function () {
                socket.emit('cancelOffer');
                jqueryMap.$submit.prop("disabled", false);
                jqueryMap.$box.empty();
              });

            });
            
            socket.on('offerTimeout', function() {
              jqueryMap.$box.empty();
              jqueryMap.$box.append( configMap.timeout_html );
              jqueryMap.$submit.prop("disabled", false);
            });
            
            socket.on('joinRoom', function(data) {
              room = data.room;
              player_id = data.player_id;
              CELL_NUM = data.CELL_NUM
              BOMB_NUM = data.BOMB_NUM;
              TIME_TO_EXPLOSION = data.TIME_TO_EXPLOSION;
              GAME_DURATIONsec = data.GAME_DURATIONsec;
              player0_color = data.player0_color;
              player1_color = data.player1_color;
              console.log('joined room : ' + room);
            });
            
            socket.on('matchReady', function(data) {
              jqueryMap.$box.empty();
              battle.configModule({
                socket : socket,
                room : room,
                player_id : player_id,
                CELL_NUM : CELL_NUM,
                BOMB_NUM : BOMB_NUM,
                TIME_TO_EXPLOSION : TIME_TO_EXPLOSION,
                GAME_DURATIONsec : GAME_DURATIONsec,
                player0_color : player0_color,
                player1_color : player1_color,
                player_nameList : data.nameList,
              });
              
              battle.configSounds({
                setBombSound : setBombSound,
                explodeSound : explodeSound,
                pointSound : pointSound,
                winSound : winSound,
                loseSound : loseSound,
              });
              
              battle.initModule( jqueryMap.$box );
            });
            
          });
          
          // ----- battle module start -----
          battle = (function () {
            'use strict';
            //----- module scope variables start -----
            var
              configMap = {
                main_html : String()
                  + '<div id="battle-info">'
                      +'<div id="info-left">'
                        +'<div id="player-name">player</div>'
                        +'<div id="player-score">score</div>'
                      +'</div>'
                      +'<div id="info-middle">VS</div>'
                      +'<div id="info-right">'
                        +'<div id="opponent-name">opponent</div>'
                        +'<div id="opponent-score">score</div>'
                      +'</div>'
                  + '</div>'
                  + '<canvas id="canvas" width="400px" height="400px">'
                    + 'ブラウザがCanvasに対応していません'
                  + '</canvas>',
                socket : null,
                room : null,
                player_id : null,
                CELL_NUM : null,
                BOMB_NUM : null,
                TIME_TO_EXPLOSION : null,
                GAME_DURATIONsec : null,
              },
              stateMap = {
                $append_target : null,
                px_per_em : 0,
                slider_hidden_px : 0,
              },
              soundsMap = {
                setBombSound : null,
                explodeSound : null,
                pointSound : null,
                winSound : null,
                loseSound : null,
              },
              jqueryMap = {},
              
              // ----- variables used in game start -----
              canvas, ctx,
              BOARD_LEN, CELL_LEN,
              ownPosition = {}, enemyPosition = {},
              STATE = {
                BLANK : 0,
                OWN_COLOR : 1,
                ENEMY_COLOR : 2,
                DEAD_END : 3
              },
              currentMatrix = [], tmpMatrix = [],
              ownScore, enemyScore,
              // ----- variables common in server and client/start -----
              CELL_NUM,
              BOMB_NUM,
              TIME_TO_EXPLOSION,
              GAME_DURATIONsec,
              // ----- variables common in server and client/end -----
              BONUS_POINT = 20,
              BOMB_RANGE = 2,
              possessedBomb, bombMatrix = [], bombList = [],
              
              ANIMATION_DT = 20,
              r_TIME_TO_EXPLOSION,
              PLAYER_COLOR_LIST = ['deeppink', 'mediumblue', 'lime', 'orange'],
              COLOR_LIST = [ 'gray' ],
              
              prepareGame, copyMatrix, drawHorizontalLine, drawVerticalLine,
              renderMatrix, renderObtainedCells, drawCharacter, setBomb, explodeBomb, drawBomb,
              evaluateEnclosure, checkPeriphery, judgeWinner, onClick,
              socketBind, onStartBattle, onSetBomb, onOrderBombExplosion, onFinishBattle,
              // ----- variables used in game end -----
              
              setJqueryMap, writeScore, writeBonus, setPxSizes,
              configModule, initModule, configSounds
            ;
            //----- module scope variables end -----
            
            //----- utility method start -----
            renderMatrix = function () {
              var i, j;
              // clear the field
              ctx.fillStyle = "white";
              ctx.fillRect( 0, 0, BOARD_LEN, BOARD_LEN);
              ctx.fill();
              // fill the field
              for ( i = 0; i < CELL_NUM; i++ ) {
                for ( j = 0; j < CELL_NUM; j++ ) {
                  ctx.beginPath();
                  if ( currentMatrix[ i ][ j ] === STATE.BLANK ) {
                    ctx.fillStyle = COLOR_LIST[ STATE.BLANK ];
                  }
                  else if ( currentMatrix[ i ][ j ] === STATE.OWN_COLOR ) {
                    ctx.fillStyle = COLOR_LIST[ STATE.OWN_COLOR ];
                  }
                  else if ( currentMatrix[ i ][ j ] === STATE.ENEMY_COLOR ) {
                    ctx.fillStyle = COLOR_LIST[ STATE.ENEMY_COLOR ];
                  }
                  ctx.fillRect( i * CELL_LEN + 0.04*CELL_LEN , j * CELL_LEN  + 0.04*CELL_LEN,
                    CELL_LEN*0.92, CELL_LEN*0.92 );
                  ctx.fill();
                }
              }
            };
            
            // effect of getting enclosed cells
            renderObtainedCells = function (obtainedCells) {
              var i, j, timer, count = 1;
              
              timer = setInterval(function() {
                renderMatrix()
                if (count >= 9) {
                  clearInterval(timer);
                  return false;
                }
                
                obtainedCells.forEach(function(val) {
                  val.forEach(function(v) {
                    ctx.beginPath();
                    i = v[0];
                    j = v[1];
                    ctx.fillStyle = "white";
                    ctx.fillRect( i * CELL_LEN + 0.1*count*CELL_LEN, j * CELL_LEN  + 0.04*CELL_LEN,
                      CELL_LEN*0.2, CELL_LEN*0.92 );
                    ctx.fill();
                  })
                });
                
                count += 1
              }, 50)
              
            };
            
            copyMatrix = function (a, b) {
              var i;
              for ( i = 0; i < CELL_NUM; i++ ) {
                b[i] = a[i].slice(0);
              }
            };
            //----- utility method end -----
            
            //----- color gang section start -----
            prepareGame = function () {
              var
                i, j, readyTimer,
                readyCount = 3
              ;
              // initialize fixed variables
              CELL_NUM = configMap.CELL_NUM;
              BOMB_NUM = configMap.BOMB_NUM;
              GAME_DURATIONsec = configMap.GAME_DURATIONsec
              TIME_TO_EXPLOSION = configMap.TIME_TO_EXPLOSION;
              r_TIME_TO_EXPLOSION = 1 / TIME_TO_EXPLOSION;
              
              ownScore = 0;
              enemyScore = 0;
              console.log("ownscore:" + ownScore);
              
              for ( i = 0; i < CELL_NUM; i++ ) {
                currentMatrix[i] = [];
                tmpMatrix[i] = [];
                bombMatrix[i] = [];
                for ( j = 0; j < CELL_NUM; j++ ) {
                  currentMatrix[i][j] = STATE.BLANK;
                  bombMatrix[i][j] = 0;
                }
              }
              
              if ( configMap.player_id === 0 ) {
                COLOR_LIST.push( PLAYER_COLOR_LIST[configMap.player0_color], PLAYER_COLOR_LIST[configMap.player1_color] );
                //COLOR_LIST.push( 'yellow', 'blue' );
                //ownPosition = { x : 0, y : 0 };
                //enemyPosition = { x : CELL_NUM - 1, y : CELL_NUM - 1 };
                
              } else if ( configMap.player_id === 1 ) {
                COLOR_LIST.push( PLAYER_COLOR_LIST[configMap.player1_color], PLAYER_COLOR_LIST[configMap.player0_color] );
                //COLOR_LIST.push( 'blue', 'yellow' );
                //ownPosition = { x : CELL_NUM - 1, y : CELL_NUM - 1 };
                //enemyPosition = { x : 0, y : 0 };
              }
              
              // get canvas and cell size
              canvas = document.getElementById('canvas');
              if ( ! canvas || ! canvas.getContext ) return false;
              BOARD_LEN = canvas.width;
              CELL_LEN = BOARD_LEN / CELL_NUM;
              ctx = canvas.getContext('2d');
              
              possessedBomb = BOMB_NUM;
              
              // set player names and score
              //console.log(configMap.player0_color, configMap.player1_color);
              //console.log(configMap.player_nameList);
              jqueryMap.$player_name.css('color', COLOR_LIST[STATE.OWN_COLOR]);
              jqueryMap.$player_name.text(configMap.player_nameList[configMap.player_id]);
              jqueryMap.$player_score.text(ownScore);
              jqueryMap.$opponent_name.css('color', COLOR_LIST[STATE.ENEMY_COLOR]);
              jqueryMap.$opponent_name.text(configMap.player_nameList[1-configMap.player_id]);
              jqueryMap.$opponent_score.text(enemyScore);
              jqueryMap.$info_middle.text(GAME_DURATIONsec);
              
              // draw field and count down
              ctx.font = "200px 'cursive'";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              readyTimer = setInterval(function() {
                if (readyCount <= 0) {
                  clearInterval(readyTimer);
                  return false;
                }
                renderMatrix();
                ctx.fillStyle = "black"
                ctx.fillText(readyCount, 200, 200);
                readyCount--;
              }, 1000);
            };
            
            //----- DOM method start -----
            // DOM method/setJqueryMap/start
            setJqueryMap = function () {
              var
                $append_target = stateMap.$append_target;
                jqueryMap = {
                  //$canvas : $('#canvas'),
                  //$offerMatch : $append_target.find( '#cg-match-offerMatch' ),
                  //$wating : $append_target.find( '.cg-match-wating' )
                  $player_name : $append_target.find('#player-name'),
                  $player_score : $append_target.find('#player-score'),
                  $opponent_name : $append_target.find('#opponent-name'),
                  $opponent_score : $append_target.find('#opponent-score'),
                  $info_middle : $append_target.find('#info-middle'),
                  // 
                  $submit : $("#match-offerMatch-submit"),
                };
            };
            // DOM method/setJqueryMap/end
            
            // DOM method/writeScore/start
            writeScore = function(bomb_color, original_score, multiplier){
              if (bomb_color == STATE.OWN_COLOR) {
                jqueryMap.$player_score.text(ownScore + '点 ' + original_score + '×' + multiplier + 'get!');
              } else if (bomb_color == STATE.ENEMY_COLOR) {
                jqueryMap.$opponent_score.text(enemyScore + '点 ' + original_score + '×' + multiplier + 'get!');
              }
            };
            // DOM method/writeScore/end
            
            // DOM method/writeBonus/start
            writeBonus = function(color){
              if (color == STATE.OWN_COLOR) {
                jqueryMap.$player_score.text(ownScore + '点 Bonus +' + BONUS_POINT + '!');
              } else if (color == STATE.ENEMY_COLOR) {
                jqueryMap.$opponent_score.text(enemyScore + '点 Bonus +' + BONUS_POINT + '!');
              }
            };
            // DOM method/writeBonus/end
            
            // DOM method/setPxSizes/start
            // DOM method/setPxSizes/end
            //----- DOM method end -----
            
            //----- event handler start -----
            onClick = function( e ) {
              var 
                xposition, yposition,
                i, j;
              
              e.preventDefault();
              if ( possessedBomb > 0 ) {
                xposition = e.clientX - canvas.offsetLeft;
                yposition = e.clientY - canvas.offsetTop;
                //console.log(xposition, yposition);
                i = Math.floor(xposition / CELL_LEN);
                j = Math.floor(yposition / CELL_LEN);
                //console.log(i, j);
                if (bombMatrix[i][j] !== 0) {
                  return false;
                } else {
                  configMap.socket.emit('askForSetBomb', {
                    room : configMap.room,
                    position : [i, j]
                    //player_id : configMap.player_id,
                  });
                }
              } else {
                return false;
              }
            }
            //----- event handler end -----
            
            //----- socket.io bind function/start -----
            onStartBattle = function () {
              var
                gameCountTimer,
                gameCount = GAME_DURATIONsec
              ;
              
              renderMatrix();
              
              // bind user input events
              $(window).click( onClick );
              $(window).bind('touchstart', function(e) {
                e.preventDefault();
                $(window).trigger($.Event( 'click' ));
              });
              
              gameCountTimer = setInterval(function() {
                if (gameCount <= 0) {
                  clearInterval(gameCountTimer);
                  return false;
                }
                gameCount--;
                jqueryMap.$info_middle.text(gameCount);
              }, 1000);
            }
            
            onSetBomb = function (data) {
              var 
                color, bomb_id = data.bomb_id,
                position = data.position;
              
              if ( data.player_id === configMap.player_id ) {
                //changed
                possessedBomb--;
                color = STATE.OWN_COLOR;
              } else if ( data.player_id === 1 - configMap.player_id ) {
                color = STATE.ENEMY_COLOR;
              } else {
                return false;
              }
              
              if(typeof(soundsMap.setBombSound.currentTime) != 'undefined') {
                soundsMap.setBombSound.currentTime = 0;
              }
              soundsMap.setBombSound.play();
              
              //setBomb( data.player_id, bomb_position, data.bomb_id );
              
              bombMatrix[ position[0] ][ position[1] ] = bomb_id;
              bombList[bomb_id] = {
                bomb_id : bomb_id,
                position : position,
                color: color,
                elapsedTime : 0,
              };
              //console.log(position);

              bombList[bomb_id].animation = setInterval( function () {
                bombList[bomb_id].elapsedTime += ANIMATION_DT;
                drawBomb( bomb_id, bombList[bomb_id].elapsedTime );
              }, ANIMATION_DT);
            };
            
            onOrderBombExplosion = function (data) {
              var
                original_score, multiplier,
                bomb_id = data.bomb_id,
                bomb_color = bombList[bomb_id].color,
                paintedCells = [], obtainedCells = []
              ;
              
              console.log('orderBombExplosion accepted with bomb_id ' + bomb_id );
              
              if(typeof(soundsMap.explodeSound.currentTime) != 'undefined') {
                soundsMap.explodeSound.currentTime = 0;
              }
              soundsMap.explodeSound.play();
              
              explodeBomb( bomb_id, paintedCells, false, 'dummy' );
              
              //renderMatrix();
              //drawCharacter( STATE.OWN_COLOR, [0,0] );
              //drawCharacter( STATE.ENEMY_COLOR, [0,0] );
              
              // console.log(paintedCells);
              obtainedCells = evaluateEnclosure( paintedCells );
              
              if (obtainedCells != null) {
                console.log("obtained!");
                if(typeof(soundsMap.pointSound.currentTime) != 'undefined') {
                  soundsMap.pointSound.currentTime = 0;
                }
                soundsMap.pointSound.play();
                
                multiplier = obtainedCells.length;
                original_score = 0;
                obtainedCells.forEach(function(val) {
                  original_score += val.length;
                });
                original_score = Math.ceil(original_score * original_score / 2);
                console.log(original_score, multiplier);
                
                renderObtainedCells(obtainedCells);
                
                // add score
                if (bomb_color == STATE.OWN_COLOR) {
                  ownScore += original_score * multiplier;
                } else if (bomb_color == STATE.ENEMY_COLOR) {
                  enemyScore += original_score * multiplier;
                }
                
                writeScore(bomb_color, original_score, multiplier);
              }
              
              renderMatrix();
              /*
              // delayed rendering
              setTimeout( function () {
                renderMatrix();
              }, 800);
              */
            };
              
            onFinishBattle = function () {
              var i, j, bomb_id;
              console.log("finish battle");
              
              // unbind socket and click event
              $(window).off( 'click' );
              // TODO touch???
              
              configMap.socket.removeListener('startBattle', onStartBattle);
              configMap.socket.removeListener('setBomb', onSetBomb);
              configMap.socket.removeListener('orderBombExplosion', onOrderBombExplosion);
              
              
              // stop animation
              for ( i = 0; i < CELL_NUM; i++ ) {
                for ( j = 0; j < CELL_NUM; j++ ) {
                  if (bombMatrix[i][j] > 0) {
                    bomb_id = bombMatrix[i][j];
                    clearInterval( bombList[bomb_id].animation );
                    drawBomb( bomb_id, bombList[bomb_id].elapsedTime );
                  }
                }
              }
              
              // buy time to show result
              setTimeout(function() {
                judgeWinner();
              }, 1000);
            };
            
            socketBind = function () {
              configMap.socket.on('startBattle', onStartBattle);
              configMap.socket.on('setBomb', onSetBomb);
              configMap.socket.on('orderBombExplosion', onOrderBombExplosion);
              configMap.socket.on('finishBattle', onFinishBattle);
            };
            //----- socket.io bind function/end -----
            
            // ----- bomb treatment start -----
            drawBomb = function ( bomb_id, elapsedTime ) {
              var
                x_origin = bombList[bomb_id].position[0] * CELL_LEN,
                y_origin = bombList[bomb_id].position[1] * CELL_LEN,
                radius = 0.2 * CELL_LEN * ( 1 + elapsedTime * r_TIME_TO_EXPLOSION ),
                color = bombList[bomb_id].color;
              
              ctx.beginPath();
              ctx.fillStyle = COLOR_LIST[ color ];
              ctx.arc( x_origin + 0.5*CELL_LEN, y_origin + 0.5*CELL_LEN, radius, 0, 2*Math.PI );
              ctx.fill();
              
              ctx.beginPath();
              ctx.arc( x_origin + 0.5*CELL_LEN, y_origin + 0.5*CELL_LEN, radius, 0, 2*Math.PI );
              ctx.stroke();
            };
            
            explodeBomb = function ( bomb_id, paintedCells, isTriggeredByOther, oringin_index ) {
              var
                n, ni, nj,
                scanningDirections = [ [1,0], [-1,0], [0,1], [0,-1] ],
                position = bombList[ bomb_id ].position,
                color = bombList[ bomb_id ].color;
                
              console.log('explodeBomb() called with bomb_id ' + bomb_id );
              copyMatrix( bombMatrix, tmpMatrix );
              
              // stop animation of bomb
              clearInterval( bombList[bomb_id].animation );
              
              // paint the bomb's explosion range in its color
              currentMatrix[ position[0] ][ position[1] ] = color;
              paintedCells.push( [ position[0], position[1] ] );
              tmpMatrix[ position[0] ][ position[1] ] = -1;
              scanningDirections.forEach( function( val, index ) {
                // avoid infinite loop and re-painting matrix
                if ( isTriggeredByOther
                  && scanningDirections[oringin_index][0] === - val[0]
                  && scanningDirections[oringin_index][1] === - val[1]
                ) {
                  return false;
                }
                
                for ( n = 1; n <= BOMB_RANGE; n++ ) {
                  ni = position[0] + n * val[0];
                  nj = position[1] + n * val[1];
                  //console.log(ni,nj);
                  if ( ni < 0 || ni >= CELL_NUM || nj < 0 || nj >= CELL_NUM ) {
                    break;
                  }
                  
                  // avoid infinite loop
                  if ( tmpMatrix[ ni ][ nj ] < 0 ) { return false; }
                  
                  // if the other bombs exist in the explosion range, detonate it
                  if ( bombMatrix[ ni ][ nj ] > 0 ) {
                    explodeBomb( bombMatrix[ ni ][ nj ], paintedCells, true, index );
                    break;
                  }
                  
                  currentMatrix[ ni ][ nj ] = color;
                  paintedCells.push( [ ni, nj ] );
                  //tmpMatrix[ ni ][ nj ] = -1;

                }
              });
              
              possessedBomb++;
              bombMatrix[ position[0] ][ position[1] ] = 0;
              
              // inform the server of completion of bomb explosion
              configMap.socket.emit('bombExploded', {
                room : configMap.room,
                bomb_id : bomb_id
              });
              // remove the object for the bomb
              bombList[bomb_id] = null;
              
            };
            
            // ---------- evaluateEnclosure/start ----------
            // This function check if cells that are surrounded by opponent color exist.
            // Check is done to cells around newly painted cells.
            evaluateEnclosure = function ( paintedCells ) {
              var
                i, j, ki, kj, ip, jp,
                lastObtainedCellsLength = 0,
                ownObtainedCells = [], ownTmpMatrix = [],
                enemyObtainedCells = [], enemyTmpMatrix = [];
                
              if ( paintedCells.length === 0 ) { return false; }
              copyMatrix( currentMatrix, ownTmpMatrix );
              copyMatrix( currentMatrix, enemyTmpMatrix );

              paintedCells.forEach( function( val ) {
                i = val[0];
                j = val[1];
                
                for( ki = -1; ki < 2; ki++ ) {
                  for( kj = -1; kj < 2; kj++ ) {
                    if ( Math.abs(ki) + Math.abs(kj) !== 1 ) { continue; }
                    ip = i + ki;
                    jp = j + kj;
                    //if ( ip < 0 || ip >= CELL_NUM || jp < 0 || jp >= CELL_NUM ) {
                    if ( ip <= 0 || ip >= CELL_NUM -1 || jp <= 0 || jp >= CELL_NUM -1 ) {
                      continue;
                    }
                    
                    if ( currentMatrix[i][j] === STATE.OWN_COLOR 
                      && currentMatrix[ip][jp] !== STATE.OWN_COLOR ) 
                    {
                      ownObtainedCells.push([]);
                      checkPeriphery( ip, jp, ownObtainedCells, ownTmpMatrix, STATE.OWN_COLOR );
                      
                      // reflect obtained cells in the matrix
                      if (ownObtainedCells.length > lastObtainedCellsLength) {
                        lastObtainedCellsLength++;
                        ownObtainedCells[ownObtainedCells.length-1].forEach( function (v) {
                          currentMatrix[v[0]][v[1]] = STATE.OWN_COLOR;
                        });
                      }
                    } else if ( currentMatrix[i][j] === STATE.ENEMY_COLOR
                      && currentMatrix[ip][jp] !== STATE.ENEMY_COLOR )
                    {
                      enemyObtainedCells.push([]);
                      checkPeriphery( ip, jp, enemyObtainedCells, enemyTmpMatrix, STATE.ENEMY_COLOR );
                      
                      // reflect obtained cells in the matrix
                      if (enemyObtainedCells.length > lastObtainedCellsLength) {
                        lastObtainedCellsLength++;
                        enemyObtainedCells[enemyObtainedCells.length-1].forEach( function (v) {
                          currentMatrix[v[0]][v[1]] = STATE.ENEMY_COLOR;
                        });
                      }
                    }
                    
                  }
                }
                
              });
  
              //console.log(ownObtainedCells);
              
              if (ownObtainedCells.length > 0) {
                return ownObtainedCells;
              } else if (enemyObtainedCells.length > 0) {
                return enemyObtainedCells;
              } else {
                return null;
              }
              
              /*
              // reflect obtained cells in the matrix
              ownObtainedCells.forEach( function ( val ) {
                val.forEach( function ( v ) {
                  currentMatrix[ v[0] ][ v[1] ] = STATE.OWN_COLOR;
                });
              });
              enemyObtainedCells.forEach( function ( val ) {
                val.forEach( function ( v ) {
                  currentMatrix[ v[0] ][ v[1] ] = STATE.ENEMY_COLOR;
                });
              });
              */
            };
            // ---------- evaluateEnclosure/end ----------
            
            // using recursive approach to find the surrounded area
            checkPeriphery = function ( n, m, obtainedCells, matrix, color ) {
              var i, j;
              //console.log(matrix);

              if ( matrix[ n ][ m ] === STATE.DEAD_END
                  || ( currentMatrix[ n ][ m ] !== color
                     && ( n - 1 < 0 || n + 1 >= CELL_NUM || m - 1 < 0 || m + 1 >= CELL_NUM ) )
              )
              {
                obtainedCells[ obtainedCells.length - 1 ].forEach( function ( v ) {
                  // memorize the positions that can't be obtained
                  matrix[ v[0] ][ v[1] ] = STATE.DEAD_END;
                });
                // remove temporary array after checked cells were found unobtainable
                obtainedCells.pop();
                return false;
              }
              
              obtainedCells[ obtainedCells.length - 1 ].push([ n, m ]);
              // memorize the positions that have been already done
              matrix[ n ][ m ] = -1
              
              for( i = -1; i < 2; i++ ) {
                for( j = -1; j < 2; j++ ) {
                  if ( Math.abs(i) + Math.abs(j) !== 1 ) { continue; }
                  if ( matrix[ n + i ][ m + j ] >= 0
                      && currentMatrix[ n + i ][ m + j ] !== color ) {
                    if ( ! checkPeriphery( n + i, m + j, obtainedCells, matrix, color) ) {
                      return false;
                    }
                  }
                }
              }
              
              return true;
            };
            // ----- bomb treatment end -----

            judgeWinner = function () {
              var 
                i, j, 
                ownTerritory = 0,
                enemyTerritory = 0
              ;
              
              configMap.socket.removeListener('finishBattle', onFinishBattle);
              
              // count each player's territory
              for ( i = 0; i < CELL_NUM; i++ ) {
                for ( j = 0; j < CELL_NUM; j++ ) {
                  if ( currentMatrix[ i ][ j ] === STATE.OWN_COLOR ) {
                    ownTerritory++;
                  } else if ( currentMatrix[ i ][ j ] === STATE.ENEMY_COLOR ) {
                    enemyTerritory++;
                  }
                }
              }
              
              console.log(ownTerritory + 'vs' + enemyTerritory);
              
              jqueryMap.$info_middle.text(ownTerritory + 'area vs.' + enemyTerritory +'area');
              if(typeof(soundsMap.pointSound.currentTime) != 'undefined') {
                soundsMap.pointSound.currentTime = 0;
              }
              soundsMap.pointSound.play();
                  

              setTimeout(function() {
                // add bonus point
                if (ownTerritory != enemyTerritory) {
                  if(typeof(soundsMap.pointSound.currentTime) != 'undefined') {
                    soundsMap.pointSound.currentTime = 0;
                  }
                  soundsMap.pointSound.play();
                }
                if (ownTerritory > enemyTerritory) {
                  ownScore += BONUS_POINT;
                  writeBonus(STATE.OWN_COLOR);
                } else if (enemyTerritory > ownTerritory) {
                  enemyScore += BONUS_POINT;
                  writeBonus(STATE.ENEMY_COLOR);
                }
                
                setTimeout(function() {
                  // show winner
                  if (ownScore > enemyScore) {
                    jqueryMap.$info_middle.text('You Win!');
                    if(typeof(soundsMap.winSound.currentTime) != 'undefined') {
                      soundsMap.winSound.currentTime = 0;
                    }
                    soundsMap.winSound.play();
                    
                  } else if (ownScore < enemyScore) {
                    jqueryMap.$info_middle.text('You Lose...');
                    if(typeof(soundsMap.loseSound.currentTime) != 'undefined') {
                      soundsMap.loseSound.currentTime = 0;
                    }
                    soundsMap.loseSound.play();
                    
                  } else {
                    jqueryMap.$info_middle.text('Draw');
                  }
                  
                  // reactivate submit-button
                  jqueryMap.$submit.prop("disabled", false);
                }, 1000);
              }, 1000);
              
            };
            
            //----- public method start -----
            // public method/configModule/start
            // purpose : coordinate the configuration of settable keys
            // arguments : settable key value map
            // 
            configModule = function ( input_map ) {
              configMap.socket = input_map.socket;
              configMap.room = input_map.room;
              configMap.player_id = input_map.player_id;
              configMap.CELL_NUM = input_map.CELL_NUM;
              configMap.BOMB_NUM = input_map.BOMB_NUM;
              configMap.TIME_TO_EXPLOSION = input_map.TIME_TO_EXPLOSION;
              configMap.GAME_DURATIONsec = input_map.GAME_DURATIONsec;
              configMap.player0_color = input_map.player0_color;
              configMap.player1_color = input_map.player1_color;
              configMap.player_nameList = input_map.player_nameList;
              return true;
            };
            // public method/configModule/end
            
            configSounds = function ( input_map ) {
              soundsMap.explodeSound = input_map.explodeSound;
              soundsMap.setBombSound = input_map.setBombSound;
              soundsMap.pointSound = input_map.pointSound;
              soundsMap.winSound = input_map.winSound;
              soundsMap.loseSound = input_map.loseSound;
              return true;
            };
          
            // public method/initModule/start
            initModule = function ( $append_target ) {
              var $list_box;
              
              // load HTML and jQuery
              $append_target.append( configMap.main_html );
              stateMap.$append_target = $append_target;
              setJqueryMap();
              
              //set canvas size. is it possible? 
              //setPxSizes();
              /*
              jqueryMap.$canvas.css({ 
                'width' : '500px',
                'height' : '500px'
              });
              */
              
              prepareGame();
              
              // bind socket event
              socketBind();
              
              
            };
          
            return {
              initModule : initModule,
              configModule : configModule,
              configSounds : configSounds
            };
            //----- public method end -----
            
          }());
          // ----- battle module end -----
        </script>

    </body>
</html>
